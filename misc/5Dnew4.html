<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <script src="../../js/setup/setup_mathjax.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    <script type="importmap">
        {
            "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/": "https://unpkg.com/three@0.160.0/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import {ThreeEngine} from '../js/utils/utils_three.js'
    import {TransformGizmoEngine} from "../js/utils/utils_transform_gizmo.js";
    import {sub_matrix_matrix} from "../js/utils/utils_math.js";
    import {normalized_matrix} from "../js/utils/utils_math.js";
    import {mul_matrix_scalar} from "../js/utils/utils_math.js";
    import {get_default_lil_gui} from "../js/utils/utils_three.js";
    import {refresh_displays} from "../js/utils/utils_three.js";
    import {set_object_orientation_from_SO3_matrix} from "../js/utils/utils_transforms.js";
    import {add_matrix_matrix} from "../js/utils/utils_math.js";
    import {mul_matrix_matrix} from "../js/utils/utils_math.js";
    import {identity_matrix} from "../js/utils/utils_math.js";
    import {transpose} from "../js/utils/utils_math.js";

    let center1_y = -5;
    let center2_y = -2.5;

    let center1 = [[0], [center1_y], [0]];
    let center2 = [[0], [center2_y], [0]];

    let engine = ThreeEngine.new_default_3d();

    let actions = {
        reset: () => {
            tge.set_position_of_gizmo(0, [1, center1_y, 0]);
            tge.set_position_of_gizmo(1, [0, center2_y + 1, 0]);
            refresh_displays(gui);
        }
    }
    let settings = {
        'rot_axis_x': 0,
        'rot_axis_y': 0,
        'rot_axis_z': 0,
        'angle': 0,
    };
    let gui = get_default_lil_gui();
    gui.add(settings, 'rot_axis_x').disable()
    gui.add(settings, 'rot_axis_y').disable()
    gui.add(settings, 'rot_axis_z').disable()
    gui.add(settings, 'angle').disable()
    gui.add(actions, 'reset')

    let tge = new TransformGizmoEngine(engine);

    engine.add_suzanne_monkey_as_mesh_object(0x00eeee);
    engine.toggle_mesh_object_wireframe_visibility(0);
    engine.set_mesh_object_visibility(0, false);

    tge.add_gizmo_SO3_matrix_and_position(engine, undefined, [1, center1_y, 0], 0.3)
    tge.add_gizmo_SO3_matrix_and_position(engine, undefined, [0, center2_y + 1, 0], 0.3)

    // --- vector utilities ---
    function vdot(a,b){ return a[0][0]*b[0][0] + a[1][0]*b[1][0] + a[2][0]*b[2][0]; }
    function vlen(a){ return Math.sqrt(vdot(a,a)); }
    function vsub(a,b){ return [[a[0][0]-b[0][0]],[a[1][0]-b[1][0]],[a[2][0]-b[2][0]]]; }
    function vscale(a,s){ return [[a[0][0]*s],[a[1][0]*s],[a[2][0]*s]]; }
    function vcross(a,b){
        return [[a[1][0]*b[2][0]-a[2][0]*b[1][0]],
            [a[2][0]*b[0][0]-a[0][0]*b[2][0]],
            [a[0][0]*b[1][0]-a[1][0]*b[0][0]]];
    }
    function vnormalize(a){
        const n = vlen(a);
        if(n < 1e-30) return [[0],[0],[0]];
        return vscale(a,1.0/n);
    }
    function mat_cols(c1,c2,c3){
        return [
            [c1[0][0], c2[0][0], c3[0][0]],
            [c1[1][0], c2[1][0], c3[1][0]],
            [c1[2][0], c2[2][0], c3[2][0]],
        ];
    }

    // --- ONB ---
    function onb_from_x(x){
        const nx=x[0][0], ny=x[1][0], nz=x[2][0];
        let y,z;
        if(nz>-0.9999999){
            const a=1.0/(1.0+nz);
            const b=-nx*ny*a;
            y=[[1.0-nx*nx*a],[b],[-nx]];
            const ylen=Math.hypot(y[0][0],y[1][0],y[2][0])+1e-30;
            y=[[y[0][0]/ylen],[y[1][0]/ylen],[y[2][0]/ylen]];
            z=vcross(x,y);
        } else {
            y=[[0],[-1],[0]];
            z=[[1],[0],[0]];
        }
        return mat_cols(x,y,z);
    }

    // --- Rodrigues (robust) ---
    function rodrigues_e1_to_x(x){
        const e1=[[1],[0],[0]];
        const c=x[0][0];
        const v=vcross(e1,x);
        const s=vlen(v);
        if(s<1e-12){
            if(c>0) return identity_matrix(3);
            const z=[[0],[0],[1]], y=[[0],[1],[0]];
            let u=vcross(z,x);
            if(vlen(u)<1e-8) u=vcross(y,x);
            u=vnormalize(u);
            const uuT=[[u[0][0]*u[0][0],u[0][0]*u[1][0],u[0][0]*u[2][0]],
                [u[1][0]*u[0][0],u[1][0]*u[1][0],u[1][0]*u[2][0]],
                [u[2][0]*u[0][0],u[2][0]*u[1][0],u[2][0]*u[2][0]]];
            const I=identity_matrix(3);
            return [
                [-I[0][0]+2*uuT[0][0], 2*uuT[0][1], 2*uuT[0][2]],
                [2*uuT[1][0], -I[1][1]+2*uuT[1][1], 2*uuT[1][2]],
                [2*uuT[2][0], 2*uuT[2][1], -I[2][2]+2*uuT[2][2]]
            ];
        }
        const vx=[[0,-v[2][0],v[1][0]],[v[2][0],0,-v[0][0]],[-v[1][0],v[0][0],0]];
        const vxvx=mul_matrix_matrix(vx,vx);
        const k=(1.0-c)/(s*s);
        const I=identity_matrix(3);
        const R=[
            [I[0][0]+vx[0][0]+k*vxvx[0][0],vx[0][1]+k*vxvx[0][1],vx[0][2]+k*vxvx[0][2]],
            [vx[1][0]+k*vxvx[1][0],I[1][1]+vx[1][1]+k*vxvx[1][1],vx[1][2]+k*vxvx[1][2]],
            [vx[2][0]+k*vxvx[2][0],vx[2][1]+k*vxvx[2][1],I[2][2]+vx[2][2]+k*vxvx[2][2]]
        ];
        return R;
    }

    // --- Quaternion utils ---
    function quat_from_mat(R){
        const m00=R[0][0],m01=R[0][1],m02=R[0][2];
        const m10=R[1][0],m11=R[1][1],m12=R[1][2];
        const m20=R[2][0],m21=R[2][1],m22=R[2][2];
        const tr=m00+m11+m22;
        let w,x,y,z;
        if(tr>0){
            const S=Math.sqrt(tr+1.0)*2;
            w=0.25*S;
            x=(m21-m12)/S;
            y=(m02-m20)/S;
            z=(m10-m01)/S;
        } else if((m00>m11)&&(m00>m22)){
            const S=Math.sqrt(1.0+m00-m11-m22)*2;
            w=(m21-m12)/S;
            x=0.25*S;
            y=(m01+m10)/S;
            z=(m02+m20)/S;
        } else if(m11>m22){
            const S=Math.sqrt(1.0+m11-m00-m22)*2;
            w=(m02-m20)/S;
            x=(m01+m10)/S;
            y=0.25*S;
            z=(m12+m21)/S;
        } else {
            const S=Math.sqrt(1.0+m22-m00-m11)*2;
            w=(m10-m01)/S;
            x=(m02+m20)/S;
            y=(m12+m21)/S;
            z=0.25*S;
        }
        const n=Math.hypot(w,x,y,z)+1e-30;
        return [w/n,x/n,y/n,z/n];
    }
    function mat_from_quat(q){
        const [w,x,y,z]=q;
        const xx=x*x,yy=y*y,zz=z*z;
        const xy=x*y,xz=x*z,yz=y*z;
        const wx=w*x,wy=w*y,wz=w*z;
        return [
            [1-2*(yy+zz),2*(xy-wz),2*(xz+wy)],
            [2*(xy+wz),1-2*(xx+zz),2*(yz-wx)],
            [2*(xz-wy),2*(yz+wx),1-2*(xx+yy)]
        ];
    }
    function quat_slerp(q0,q1,t){
        let dot=q0[0]*q1[0]+q0[1]*q1[1]+q0[2]*q1[2]+q0[3]*q1[3];
        let qa=q1.slice();
        if(dot<0){dot=-dot;qa=[-q1[0],-q1[1],-q1[2],-q1[3]];}
        if(dot>0.9995){
            const out=[
                q0[0]+t*(qa[0]-q0[0]),
                q0[1]+t*(qa[1]-q0[1]),
                q0[2]+t*(qa[2]-q0[2]),
                q0[3]+t*(qa[3]-q0[3])
            ];
            const n=Math.hypot(out[0],out[1],out[2],out[3])+1e-30;
            return [out[0]/n,out[1]/n,out[2]/n,out[3]/n];
        }
        const theta0=Math.acos(dot);
        const s0=Math.sin((1-t)*theta0);
        const s1=Math.sin(t*theta0);
        const s=Math.sin(theta0);
        return [
            (q0[0]*s0+qa[0]*s1)/s,
            (q0[1]*s0+qa[1]*s1)/s,
            (q0[2]*s0+qa[2]*s1)/s,
            (q0[3]*s0+qa[3]*s1)/s
        ];
    }

    // --- Correct blending weight ---
    const ROD_T = 0.9;
    const ROD_EPS = 0.05;
    function rodrigues_weight_from_x(x){
        const d = x[0][0];
        return 0.5 * (1 + Math.tanh(((-d) - ROD_T) / ROD_EPS));
    }

    // --- main loop ---
    engine.animation_loop(() => {
        engine.draw_debug_number_line(center1, [1,0,0],undefined,undefined,0xee0000);
        engine.draw_debug_number_line(center1, [0,1,0],undefined,undefined,0x00ee00);
        engine.draw_debug_number_line(center1, [0,0,1],undefined,undefined,0x0000ee);

        let point1 = tge.get_gizmo_pose_as_SO3_matrix_and_position(0)[1];
        let point2 = tge.get_gizmo_pose_as_SO3_matrix_and_position(1)[1];
        point2[2][0]=0;

        let v1 = sub_matrix_matrix(point1,center1);
        let x = normalized_matrix(v1);

        let vec2 = sub_matrix_matrix(point2,center2);
        let theta = Math.atan2(vec2[1][0],vec2[0][0]);
        settings.angle = theta;
        tge.set_position_of_gizmo(1,[point2[0][0],point2[1][0],0]);

        let R_onb = onb_from_x(x);
        let R_min = rodrigues_e1_to_x(x);

        const w = rodrigues_weight_from_x(x);
        const q_onb = quat_from_mat(R_onb);
        const q_min = quat_from_mat(R_min);
        const q_align = quat_slerp(q_onb,q_min,w);
        let R_align = mat_from_quat(q_align);

        let Rx = [
            [1.0,0.0,0.0],
            [0.0,Math.cos(theta),-Math.sin(theta)],
            [0.0,Math.sin(theta),Math.cos(theta)]
        ];
        let R = mul_matrix_matrix(R_align,Rx);

        settings.rot_axis_x = x[0][0];
        settings.rot_axis_y = x[1][0];
        settings.rot_axis_z = x[2][0];

        set_object_orientation_from_SO3_matrix(engine,0,R);
        refresh_displays(gui);
    });
</script>
</body>
</html>
